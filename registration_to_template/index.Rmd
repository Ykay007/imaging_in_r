---
title: "Registration to a Template in R"
author: "Neurohacking"
date: "`r format(Sys.Date(), '%b %d,%Y')`"
output:
  beamer_presentation:
    includes:
      in_header: ../beamer_header.txt
---


```{r, echo=FALSE, cache=FALSE}
library(knitr)
options(fsl.path = "/usr/local/fsl/")
options(fsl.outputtype = "NIFTI_GZ")
opts_chunk$set(echo = TRUE, comment = "")
```


## Types of Registration
- Rigid-body registration (linear) - 6 degrees of freedom (dof)
    - Co-registration (within the same person)
        - Cross-sectional between-sequences
        - Longitudinal within-sequence
        - Longitudinal between-sequences
- Affine registration â€“ 12 dof
- **Non-linear (> 12 dof)**
    - **Usually require a prior affine registration**
    - Across-subject registration
    - **Registration to a template**
        - There are many different templates
    
## Revisitsing Rigid Registration: The Math
For a voxel $v$, the rigid transformation can be written as:

$$T_{\rm rigid}(v) = Rv + t$$
where $R =$
\small
$$\left[\begin{array}{ccc} \cos\beta\cos\gamma& \cos\alpha\sin\gamma + \sin\alpha\sin\beta\cos\gamma & \sin\alpha\sin\gamma - \cos\alpha\sin\beta\cos\gamma \\
-\cos\beta\sin\gamma & \cos\alpha\cos\gamma - \sin\alpha\sin\beta\sin\gamma & \sin\alpha\cos\gamma + \cos\alpha\sin\beta\sin\gamma \\
\sin\beta & -\sin\alpha\cos\beta & \cos\alpha\cos\beta \end{array}\right]$$
\normalsize

- $6$ degrees of freedom
- $3$ associated with the translation vector: $t=(t_x, t_y, t_z)$
- $3$ associated with the rotation parameters: $\theta=(\alpha, \beta,\gamma)$. 


## Affine Registration: The Math
For a voxel $v$, the affine transformation can be written as:

$$T_{\rm affine}(v) = Av + t$$
where 
\small
$$A = \left[\begin{array}{ccc} r_{1,1}& r_{1,2} & r_{1,3} \\
r_{2,1}& r_{2,2} & r_{2,3} \\
r_{3,1}& r_{3,2} & r_{3,3} \\
\end{array}\right]$$
\normalsize

- $12$ degrees of freedom
- $3$ associated with the translation vector: $t=(t_x, t_y, t_z)$
- $9$ associated with the rotation parameters: $r_{i,j}$. 


## Overall Framework
\includegraphics{Non_Linear_Registration_Figure.png}

## Registration to a template
- Commonly requires an affine transformation
    - brain may be different sizes and in different spaces
    - translate/rotate as in rigid-body registration
    - Also scale up or down in size and shearing
- After an affine transformation the image is non-linearly transformed
  - Usually achieves better local agreement
  - Can change the volume of structures differentially

## Reading in the T1 brain
We will read in the brain-extracted, co-registered T1:

```{r read_t1}
library(neurobase)
library(ms.lesion)
files = get_image_filenames_list_by_subject(
    type = "coregistered")$training01
t1_fname = files["MPRAGE"]
t1 = readnii(t1_fname)
```

## Confirm it's just the brain

```{r ortho_t1}
ortho2(t1)
```


## Affine register the T1 to Eve Brain and apply transform to other images

Using `extrantsr::registration` with an affine transformation and a linear interpolation:

```{r aff_reg_eve, eval = FALSE}
library(extrantsr); library(EveTemplate);
eve_brain_fname = getEvePath(what = "Brain")
eve_brain = readnii(eve_brain_fname)
mods = c("T2", "FLAIR", "PD")
other_files = files[mods]
outfile = "T1_to_Eve.nii.gz"
other_outfiles = paste0(mods, "_to_Eve.nii.gz")
names(other_outfiles) = mods
reg = registration(filename = files["MPRAGE"], 
  outfile = outfile, template.file = eve_brain,
  interpolator = "Linear", typeofTransform = "Affine",
  other.files = other_files, other.outfiles = other_outfiles)
out_imgs = check_nifti(c(MPRAGE = outfile, other_outfiles))
```

```{r aff_reg_eve_run, eval = TRUE, echo = FALSE}
library(extrantsr); library(EveTemplate);
eve_brain_fname = getEvePath(what = "Brain")
eve_brain = readnii(eve_brain_fname)
outfiles = get_image_filenames_list_by_subject(
  type = "affine")
mods = c("MPRAGE", "T2", "FLAIR", "PD")
outfiles = outfiles$training01[mods]
out_imgs = check_nifti(outfiles)
```

## Affine Registration Results

```{r aff_reg_plot_t1}
double_ortho(eve_brain, out_imgs$MPRAGE)
```


## Registration Results: FLAIR

```{r aff_reg_plot_flair}
double_ortho(eve_brain, out_imgs$FLAIR)
```



## Non-Linear Registration: T1 to Eve


We can do a non-linear transformation (SyN) with the same code, but change `typeofTransform = "SyN"`.  SyN performs an affine registration before the non-linear component:

```{r reg_eve, eval = FALSE}
library(extrantsr); library(EveTemplate);
eve_brain_fname = getEvePath(what = "Brain")
eve_brain = readnii(eve_brain_fname)
mods = c("T2", "FLAIR", "PD")
other_files = files[mods]
outfile = "T1_to_Eve.nii.gz"
other_outfiles = paste0(mods, "_to_Eve.nii.gz")
names(other_outfiles) = mods
reg = registration(filename = files["MPRAGE"], 
  outfile = outfile, template.file = eve_brain,
  interpolator = "Linear", typeofTransform = "SyN",
  other.files = other_files, other.outfiles = other_outfiles)
syn_out_imgs = check_nifti(c(MPRAGE = outfile, other_outfiles))
```

```{r reg_eve_run, eval = TRUE, echo = FALSE}
library(extrantsr); library(EveTemplate);
outfiles = get_image_filenames_list_by_subject(type = "template")
mods = c("MPRAGE", "T2", "FLAIR", "PD")
outfiles = outfiles$training01[mods]
syn_out_imgs = check_nifti(outfiles)
```

## SyN Registration Results

```{r reg_plot_t1}
double_ortho(eve_brain, syn_out_imgs$MPRAGE)
```

## SyN Registration Results: FLAIR

```{r reg_plot_flair}
double_ortho(eve_brain, syn_out_imgs$FLAIR)
```

## Affine vs. SyN Registration Results: FLAIR

```{r reg_compare_plot}
double_ortho(out_imgs$MPRAGE, syn_out_imgs$MPRAGE)
```

<!-- ## Reading in the atlas and look up table (LUT) -->
<!-- ```{r eve_labels} -->
<!-- #### extracting JHU Eve atlas Type I an labels########### -->
<!-- atlas = "JHU_MNI_SS_WMPM_Type-I" -->
<!-- txtfile = file.path(neurodir, "Template", -->
<!--                     paste0(atlas, "_SlicerLUT.txt")) -->
<!-- ### read look up table (LUT) -->
<!-- jhut1.df = read.table(txtfile, stringsAsFactors=FALSE) -->
<!-- jhut1.df = jhut1.df[, 1:2] -->
<!-- colnames(jhut1.df) = c("index", "Label") -->
<!-- jhut1.df$index = as.numeric(jhut1.df$index) -->
<!-- ## read in the template image -->
<!-- jhut1.img = readNIfTI( -->
<!--   file.path(neurodir, "Template",  -->
<!--             paste0(atlas, ".nii.gz"))) -->
<!-- uimg = sort(unique(c(jhut1.img))) -->
<!-- all.ind = jhut1.df$index -->
<!-- stopifnot(all(uimg %in% all.ind)) -->
<!-- ``` -->


<!-- ## After the warping and interpolation, the ROI is no longer binary -->

<!-- ```{r syn_roi} -->
<!-- hist(c(syn_roi[syn_roi > 0])) -->
<!-- ``` -->

<!-- ## Interpolated ROI is not binary -->
<!-- To estimate the tumor/ROI engagement with areas of the brain we can: -->

<!-- 1.  Threshold the ROI to binary -->
<!-- 2.  Use a weighted sum over the ROI -->

<!-- ## ROI engagement results: engagement of **tumor by region** -->

<!-- Here we make a `data.frame` with the index for the atlas and the value of the ROI for that voxel, take the sum of the ROI by atlas label then scale it to 100%. -->

<!-- ```{r thresh_syn_roi} -->
<!-- library(plyr) -->
<!-- roi.df = data.frame(index = jhut1.img[syn_roi> 0],  -->
<!--                     roi = syn_roi[ syn_roi > 0]) -->
<!-- label_sums = ddply(roi.df, .(index), summarize, -->
<!--   sum_roi = sum(roi), sum_roi_thresh = sum(roi > 0.5) ) -->
<!-- label_sums = merge(label_sums, jhut1.df, by="index") -->
<!-- sums = label_sums # will use later -->
<!-- rownames(label_sums) = label_sums$Label -->
<!-- label_sums$Label = label_sums$index = NULL -->
<!-- label_sums = label_sums[ order(label_sums$sum_roi, -->
<!--                          decreasing = TRUE), ] -->
<!-- ``` -->


<!-- ## ROI engagement results: top 10 regions -->
<!-- Each number represents the percentage of the tumor engaging that region. -->
<!-- \small -->
<!-- ```{r thresh_syn_roi_res} -->
<!-- # scale to percent -->
<!-- label_pct = t(t(label_sums)/colSums(label_sums)) * 100 -->
<!-- head(round(label_pct, 1), 10) -->
<!-- ``` -->
<!-- \normalsize -->


<!-- ## ROI engagement results: engagement of **region by tumor** -->
<!-- Each number represents the percentage of the region engaged by the tumor. -->

<!-- ```{r thresh_syn_roi_res_region} -->
<!-- jhut1.tab = as.data.frame(table(c(jhut1.img))) -->
<!-- colnames(jhut1.tab) = c("index", "size") -->
<!-- region_pct = merge(sums, jhut1.tab, by="index") -->
<!-- rownames(region_pct) = sums$Label -->
<!-- region_pct$Label = region_pct$index = NULL -->
<!-- region_pct = region_pct/region_pct$size * 100 -->
<!-- region_pct$size = NULL -->
<!-- region_pct = region_pct[ order(region_pct$sum_roi, -->
<!--                          decreasing = TRUE), ] -->
<!-- ``` -->



<!-- ## 10 regions with largest percent of region engaged by tumor -->
<!-- Each number represents the percentage of the region engaged by the tumor. -->
<!-- \small -->
<!-- ```{r thresh_syn_roi_res_region_print} -->
<!-- head(round(region_pct, 1), 10) -->
<!-- ``` -->
<!-- \normalsize -->



## Registration to a template wrap up

- Here we showed how to:

1.  Register an skull stripped T1 to a skull-stripped template (Eve)
2.  Apply the transformation to a region of interest (ROI) from another MRI sequence (FLAIR)
3. Use an atlas in the same space as the template to get measurements of ROI engagement/overlap 



## Registration to a template wrap up 


- Registration to a template can be done in R with the same code as in linear registration
    - `ants_regwrite` wraps around the reading/writing of images and applying transformations
    - `double_ortho` and `ortho2` can provide some basic visual checks to assess registration quality
- Once images from multiple individuals are registered in template space you can do population-level analysis



