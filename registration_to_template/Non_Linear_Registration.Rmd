---
title: "Registration to a Template in R"
author: "Neurohacking"
date: "`r format(Sys.Date(), '%b %d,%Y')`"
output:
  beamer_presentation:
    includes:
      in_header: ../beamer_header.txt
---


```{r, echo=FALSE, cache=FALSE}
library(knitr)
options(fsl.path = "/usr/local/fsl/")
options(fsl.outputtype = "NIFTI_GZ")
opts_chunk$set(message = FALSE, echo = TRUE, cache = TRUE, comment = "",
               warning = FALSE)
```

## Types of Registration
- Rigid-body registration (linear) - 6 degrees of freedom (dof)
    - Co-registration (within the same person)
        - Cross-sectional between-sequences
        - Longitudinal within-sequence
        - Longitudinal between-sequences
- Affine registration â€“ 12 dof
- **Non-linear (> 12 dof)**
    - **Usually require a prior affine registration**
    - Across-subject registration
    - **Registration to a template**
        - There are many different templates
    
## Revisitsing Rigid Registration: The Math
For a voxel $v$, the rigid transformation can be written as:

$$T_{\rm rigid}(v) = Rv + t$$
where $R =$
\small
$$\left[\begin{array}{ccc} \cos\beta\cos\gamma& \cos\alpha\sin\gamma + \sin\alpha\sin\beta\cos\gamma & \sin\alpha\sin\gamma - \cos\alpha\sin\beta\cos\gamma \\
-\cos\beta\sin\gamma & \cos\alpha\cos\gamma - \sin\alpha\sin\beta\sin\gamma & \sin\alpha\cos\gamma + \cos\alpha\sin\beta\sin\gamma \\
\sin\beta & -\sin\alpha\cos\beta & \cos\alpha\cos\beta \end{array}\right]$$
\normalsize

- $6$ degrees of freedom
- $3$ associated with the translation vector: $t=(t_x, t_y, t_z)$
- $3$ associated with the rotation parameters: $\theta=(\alpha, \beta,\gamma)$. 


## Affine Registration: The Math
For a voxel $v$, the affine transformation can be written as:

$$T_{\rm affine}(v) = Av + t$$
where 
\small
$$A = \left[\begin{array}{ccc} r_{1,1}& r_{1,2} & r_{1,3} \\
r_{2,1}& r_{2,2} & r_{2,3} \\
r_{3,1}& r_{3,2} & r_{3,3} \\
\end{array}\right]$$
\normalsize

- $12$ degrees of freedom
- $3$ associated with the translation vector: $t=(t_x, t_y, t_z)$
- $9$ associated with the rotation parameters: $r_{i,j}$. 


## Overall Framework
\includegraphics{Non_Linear_Registration_Figure.png}

## Registration to a template
- Commonly requires an affine transformation
    - brain may be different sizes and in different spaces
    - translate/rotate as in rigid-body registration
    - Also scale up or down in size and shearing
- After an affine transformation the image is non-linearly transformed
  - Usually achieves better local agreement
  - Can change the volume of structures differentially

## Reading in the T1 scan from BRAINIX
We will use the data from the BRAINIX dataset.  Here we read in the T1:

```{r reg_read_t1, echo=TRUE, message=FALSE}
library(oro.nifti)
library(extrantsr)
library(fslr)
library(scales)
neurodir = path.expand("~/Neurohacking_data")
mridir = file.path(neurodir, "BRAINIX", "NIfTI")
t1 = file.path(mridir, "T1.nii.gz")
t1 = readNIfTI(t1, reorient = FALSE)
```

```{r window_t1, echo=FALSE, message=FALSE, results='hide'}
t1 = robust_window(t1)
```

## A region of interest (ROI) of a tumor from the FLAIR

```{r disp_roi}
flair = file.path(mridir, "FLAIR.nii.gz")
roi = file.path(mridir, "ROI.nii.gz")
```
```{r plot_roi, echo=FALSE}
library(scales)
flair_img = robust_window(readNIfTI(flair, reorient = FALSE))
roi_img = readNIfTI(roi, reorient = FALSE)
ortho2(flair_img, roi_img, col.y=alpha("red", 0.5), xyz=xyz(roi_img))
```

```{r img_for_figure, results='hide', echo = FALSE}
t1_plot_img = dropEmptyImageDimensions(t1)
t1_plot_img = robust_window(t1_plot_img)
plot_imgs = dropEmptyImageDimensions(flair_img, other.imgs = roi_img)
flair_plot_img = plot_imgs$outimg
roi_plot_img = plot_imgs$other.imgs
```

```{r flair_for_figure, echo=FALSE, include=FALSE, fig.height=5, fig.width=4}
image(flair_plot_img, z = 11, plot.type = "single")
title(main = c("", "", "FLAIR Image"), outer= TRUE, col.main="white", cex.main=3)
```
```{r roi_for_figure, echo=FALSE, include=FALSE, fig.height=5, fig.width=4}
image(roi_plot_img, z = 11, plot.type = "single")
title(main = c("", "", "Tumor ROI"), outer= TRUE, col.main="white", cex.main=3)
```
```{r t1_for_figure, echo=FALSE, include=FALSE, fig.height=5, fig.width=4}
image(t1_plot_img, z = 11, plot.type = "single")
title(main = c("", "", "T1 Image"), outer= TRUE, col.main="white", cex.main=3)
```


## We will register the FLAIR to the T1 and apply the transform to the ROI.

```{r reg_flair}
reg_flair = file.path(mridir, 
                      "FLAIR_regToT1.nii.gz")
reg_roi = file.path(mridir, 
                    "ROI_regToT1.nii.gz")
reg_flair_img = ants_regwrite(filename = flair, 
                              template.file = t1, 
                              outfile = reg_flair, 
                              typeofTransform = "Rigid",
                              other.files = roi,
                              other.outfiles = reg_roi,
                              verbose = FALSE)
reg_roi_img = readNIfTI(reg_roi, reorient = FALSE)
```

```{r window_falir, echo=FALSE}
reg_flair_img = robust_window(reg_flair_img)
```

## FLAIR Registration Results

```{r reg_plot_flair}
double_ortho(t1, 
             reg_flair_img)
```

## FLAIR Registration Results: ROI Overlay

```{r reg_plot_flair_overlay}
ortho2(reg_flair_img, reg_roi_img,
       col.y = alpha("red", 0.2), 
       xyz=xyz(reg_roi_img))
```

## Registered ROI Overlaid on T1

```{r reg_plot_roi_overlay}
ortho2(t1, reg_roi_img, col.y = alpha("red", 0.2), 
       xyz=xyz(reg_roi_img))
```


## Skull-Stripping T1 image
We are going to register the T1 image to the MNI template.  We want to match brain structures well, without any outside brain areas affecting the registration, so we will skull strip the T1.  We N4-correct the T1 (`extrantsr::bias_correct`) and skull-strip the image using `extrantsr::fslbet_robust`.

```{r bet_t1}
n4_t1 = bias_correct(t1, correction = "N4")
brain = fslbet_robust(img = n4_t1,
                      correct = FALSE, 
                      verbose = FALSE)
```


## Affine Registration of T1 to the template
We are going to register the T1 image to the MNI template.  We want to match brain structures well, without any outside brain areas affecting the registration, so we will skull strip the T1.

Here we do an affine registration:
\small
```{r affine_t1}
template.file = file.path(neurodir, "Template", 
                          "JHU_MNI_SS_T1_brain.nii.gz")
aff_t1_outfile = file.path(mridir, 
                           "T1_AffinetoEve.nii.gz")
aff_roi_outfile = file.path(mridir, 
                            "ROI_regToT1_AffinetoEve.nii.gz")
aff_brain = ants_regwrite(filename = brain, 
                          outfile = aff_t1_outfile,
                          other.files = reg_roi,
                          other.outfiles = aff_roi_outfile,
                          template.file = template.file, 
                          typeofTransform = "Affine",
                          verbose = FALSE)
aff_roi = readNIfTI(aff_roi_outfile, reorient = FALSE)
```
\normalsize

## Affine T1 Registration to Template Results

```{r aff_t1_template_plot}
template = readNIfTI(template.file, reorient = FALSE)
double_ortho(aff_brain, template)
```


```{r template_for_figure, echo=FALSE, include=FALSE, fig.height=5, fig.width=4}
template_plot_img = copyNIfTIHeader(template, 
                                    arr = template[16:163,21:217,3:154])
image(template_plot_img, z = 76, plot.type = "single")
title(main = c("", "", "Template Image"), outer= TRUE, col.main="white", cex.main=3)
```

## Affine T1 Registration to Template Results: Overlay

```{r aff_t1_template_overlay}
ortho2(aff_brain, template, 
       col.y = alpha(hotmetal(), 0.35))
```

## Affine T1 Registration to Template Results: Overlay One Slice

\small
```{r aff_t1_template_overlay_func}
overlay(aff_brain, template, 
        z = ceiling(dim(template)[3]/2), 
        plot.type = "single", 
       col.y = alpha(hotmetal(), 0.15))
```
\normalsize

## Affine T1 Registration to Template Results: ROI Overlay

```{r aff_t1_roi_overlay}
ortho2(aff_brain, aff_roi, 
       col.y = alpha(hotmetal(), 0.35),
       xyz=xyz(aff_roi))
```


## Diffeomorphic Registration of T1 to the template
Here we will use symmetric image normalization (SyN), which is a symmetric diffeomorphic registration technique.  The registration is non-linear and matches the image to the template well.  SyN performs an affine registration before running, so we can simply pass in the original image.

```{r syn_t1}
syn_t1_outfile = file.path(mridir, 
                       "T1_SyNtoEve.nii.gz")
syn_roi_outfile = file.path(mridir, 
                        "ROI_regToT1_SyNtoEve.nii.gz")
syn_brain = ants_regwrite(filename = brain, 
                          outfile = syn_t1_outfile,                          
                          other.files = reg_roi,
                          other.outfiles = syn_roi_outfile,
                          template.file = template.file, 
                          typeofTransform = "SyN",
                          verbose = FALSE)
syn_roi = readNIfTI(syn_roi_outfile, reorient = FALSE)
```

## SyN T1 Registration to Template Results

```{r syn_t1_template_plot}
double_ortho(syn_brain, template)
```

## SyN T1 Registration to Template Results: Overlay

```{r syn_t1_template_overlay}
ortho2(syn_brain, template, 
       col.y = alpha(hotmetal(), 0.25))
```

## SyN T1 Registration to Template Results: Overlay One Slice

\small
```{r syn_t1_template_overlay_func}
overlay(syn_brain, template, z = ceiling(dim(template)[3]/2), 
        plot.type = "single", 
       col.y = alpha(hotmetal(), 0.15))
```
\normalsize

## Affine T1 Registration to Template Results: Overlay One Slice

\small
```{r aff_t1_template_overlay_func2}
overlay(aff_brain, template, z = ceiling(dim(template)[3]/2), 
        plot.type = "single", 
       col.y = alpha(hotmetal(), 0.15))
```
\normalsize

## SyN T1 Registration to Template Results: ROI Overlay

```{r syn_t1_roi_overlay}
ortho2(syn_brain, syn_roi, 
       col.y = alpha(hotmetal(), 0.25),
       xyz=xyz(syn_roi))
```

## SyN Results: ROI Overlay on template

```{r syn_t1_roi_overlay_on_template}
ortho2(template, syn_roi, 
       col.y = alpha(hotmetal(), 0.25),
       xyz=xyz(syn_roi))
```

## Reading in the atlas and look up table (LUT)
```{r eve_labels}
#### extracting JHU Eve atlas Type I an labels###########
atlas = "JHU_MNI_SS_WMPM_Type-I"
txtfile = file.path(neurodir, "Template",
                    paste0(atlas, "_SlicerLUT.txt"))
### read look up table (LUT)
jhut1.df = read.table(txtfile, stringsAsFactors=FALSE)
jhut1.df = jhut1.df[, 1:2]
colnames(jhut1.df) = c("index", "Label")
jhut1.df$index = as.numeric(jhut1.df$index)
## read in the template image
jhut1.img = readNIfTI(
  file.path(neurodir, "Template", 
            paste0(atlas, ".nii.gz")))
uimg = sort(unique(c(jhut1.img)))
all.ind = jhut1.df$index
stopifnot(all(uimg %in% all.ind))
```


## After the warping and interpolation, the ROI is no longer binary

```{r syn_roi}
hist(c(syn_roi[syn_roi > 0]))
```

## Interpolated ROI is not binary
To estimate the tumor/ROI engagement with areas of the brain we can:

1.  Threshold the ROI to binary
2.  Use a weighted sum over the ROI

## ROI engagement results: engagement of **tumor by region**

Here we make a `data.frame` with the index for the atlas and the value of the ROI for that voxel, take the sum of the ROI by atlas label then scale it to 100%.

```{r thresh_syn_roi}
library(plyr)
roi.df = data.frame(index = jhut1.img[syn_roi> 0], 
                    roi = syn_roi[ syn_roi > 0])
label_sums = ddply(roi.df, .(index), summarize,
  sum_roi = sum(roi), sum_roi_thresh = sum(roi > 0.5) )
label_sums = merge(label_sums, jhut1.df, by="index")
sums = label_sums # will use later
rownames(label_sums) = label_sums$Label
label_sums$Label = label_sums$index = NULL
label_sums = label_sums[ order(label_sums$sum_roi,
                         decreasing = TRUE), ]
```


## ROI engagement results: top 10 regions
Each number represents the percentage of the tumor engaging that region.
\small
```{r thresh_syn_roi_res}
# scale to percent
label_pct = t(t(label_sums)/colSums(label_sums)) * 100
head(round(label_pct, 1), 10)
```
\normalsize


## ROI engagement results: engagement of **region by tumor**
Each number represents the percentage of the region engaged by the tumor.

```{r thresh_syn_roi_res_region}
jhut1.tab = as.data.frame(table(c(jhut1.img)))
colnames(jhut1.tab) = c("index", "size")
region_pct = merge(sums, jhut1.tab, by="index")
rownames(region_pct) = sums$Label
region_pct$Label = region_pct$index = NULL
region_pct = region_pct/region_pct$size * 100
region_pct$size = NULL
region_pct = region_pct[ order(region_pct$sum_roi,
                         decreasing = TRUE), ]
```



## 10 regions with largest percent of region engaged by tumor
Each number represents the percentage of the region engaged by the tumor.
\small
```{r thresh_syn_roi_res_region_print}
head(round(region_pct, 1), 10)
```
\normalsize



## Registration to a template wrap up

- Here we showed how to:

1.  Register an skull stripped T1 to a skull-stripped template (Eve)
2.  Apply the transformation to a region of interest (ROI) from another MRI sequence (FLAIR)
3. Use an atlas in the same space as the template to get measurements of ROI engagement/overlap 



## Registration to a template wrap up 


- Registration to a template can be done in R with the same code as in linear registration
    - `ants_regwrite` wraps around the reading/writing of images and applying transformations
    - `double_ortho` and `ortho2` can provide some basic visual checks to assess registration quality
- Once images from multiple individuals are registered in template space you can do population-level analysis



