---
title: "Reading and Writing Images"
author: "Kristin Linn"
output:
  ioslides_presentation:
    widescreen: yes
    css: ../styles.css
bibliography: ../refs.bib       
---

```{r setup, include=FALSE}
library(methods)
knitr::opts_chunk$set(echo = TRUE, comment = "")
```


## Formats of Images

There are multiple imaging formats.  We will use NIfTI:

* NIfTI - Neuroimaging Informatics Technology Initiative (https://nifti.nimh.nih.gov/nifti-1)
    - essentially a header and data (binary format)
    - will have extension .nii (uncompressed) or .nii.gz (compressed)
    - we will primarily use compressed NIfTI images
    - we will use 3-D images (4-D and 5-D are possible)
* ANALYZE 7.5 was a precursor to NIfTI 
    - had a `hdr` file (header) and `img` file (data)


# An Imaging into to R

## What is a package?

A package is collection of functions, documentation, data, and tutorials (called vignettes).

- You install a package using the `install.packages` command/function:

```r
install.packages("oro.nifti")
```

`install.packages` is a function, `"oro.nifti"` is a character string.


## Loading Packages

When you install a package, that means it's downloaded on your computer.  That **doesn't** mean that you can use the functions from that package just yet.

- You "load"/import a package into memory using the `library` command

For example, to load the `oro.nifti` package:

```r
library(oro.nifti)
```

Now, functions from the `oro.nifti` package can be used.

## Some packages we will use

All packages we will discuss are loaded on the RStudio Server:

* `oro.nifti` - reading/writing NIfTI images
* `neurobase` - extends `oro.nifti` and provides helpful imaging functions

Let's load them:

```{r, message=FALSE}
library(oro.nifti)
library(neurobase)
```

## Reading in NIfTI images: assignment

We will use the `readnii` function (from `neurobase`) to read in a `nifti` object (this is an `R` object).

Here we read in the `training01_01_mprage.nii.gz` file, and assign it to an object called `t1`
```{r}
t1 = readnii("training01_01_mprage.nii.gz")
```

Now, an object `t1` is in memory/the workspace.

## Reading in NIfTI images: assignment

In `R`, you can assign using the equals `=` or arrow `<-` (aka assigment operator).

The above command is equivalent to:

```{r, eval = FALSE}
t1 <- readnii("training01_01_mprage.nii.gz")
```

There are no differences in these 2 commands, but just personal preference.


---

By default, if you simply pass the object, it is printed, we can also do `print(t1)`:
```{r}
class(t1)
t1
```

## Help

- To see the documentation for a function, use the `?` symbol before the name of the function.  This is a shortcut for the `help` command:
- For example, to see documentation for `readnii`:

```{r help, eval = FALSE}
?readnii
help(topic = "readnii")
```
- To search for help files, use a double `??` or `help.search`:

```{r help2, eval = FALSE}
??readnii
help.search(pattern = "readnii")
```

## Some Details

- R is case sensitive (e.g. `y` and `Y` are different)
- Commands separated by new line or by a colon (;)
- Use `#` to comment
- Functions and commands in a separate file, say `myCode.R`, may be executed using 

```{r source, eval=FALSE}
source("myCode.R")
```

## Data Classes

Data Classes:

- Numeric - numbers (e.g. 1, 3.673)
- Character - strings or words (`"hey"`, `"I'm a string"`) in either single or double quotes
- Logicals - `TRUE` or `FALSE` - all capital letters and are **not** in quotes. 

## Data Types

Data Types

- `vector` - 1-dimensional object of one class (all numeric or all character)
- `matrix` - 2-dimensional object of one class
- `data.frame` - 2-dimensional object, can be multiple classes (like Excel spreadsheet)
- `array` - object of dimensions > 2 of one class.  The data in a `nifti` object is one of these (usually 3-D)
- `nifti` - an array with header information
- `list` - a general holder of things (discuss when necessary)


## Vectors

- Create a vector of numeric values and assign to variable `v`

```{r vec}
v = c(1, 4, 3, 7, 8)
```

- Subsetting (first index is `1`, not zero):
```{r vecSub}
print(v[4])
print(v[1:3])
print(v[c(1,3,5)])
```

`:` creates a sequence of numbers

## Matrices

- Create a 3 x 4 numeric matrix and assign to variable `m`
```{r mat}
m = matrix(1:12, nrow = 3)
```

- Subsetting - `[row,column]` format, if `row` or `column` missing then all values:
```{r matSub}
print(m[,4])
print(m[2,])
print(m[1,3])
print(m[1:2,3:4])
```

## Subsetting with logicals 

You can either do subsetting with indices or logical vectors:
```{r}
v[ v > 5 ]
```
the `which` command takes a logical and gets the indices:
```{r}
which(v > 5)
v[ which(v > 5) ]
```


## Working with `nifti` objects

The subsetting here is similar to that of arrays, so we will use the `t1`. Since it's 3-dimensions the subsetting goes to the 3rd dimension
```{r}
t1[5, 4, 3]
```

```{r, eval = FALSE}
t1[5, 4, ] # returns a vector of numbers (1-d)
t1[, 4, ] # returns a 2-d matrix
t1[1, , ] # returns a 2-d matrix
```

## Working with `nifti` objects

Again, we can use a logical operation.  Let's get the values of the `t1` greater than 400 (`head` only prints the first 6 values):

```{r}
head(t1[ t1 > 400 ])
```

## Working with `nifti` objects

The operation results in a `nifti` object, and if we look at the values, they are logical:
```{r}
class(t1 > 400)
head(t1 > 400)
```
## `which` with `nifti` objects

The `which` function works to get indices, but you can pass the `arr.ind = TRUE` argument to get "array" indices:

```{r}
head(which(t1 > 400, arr.ind = TRUE))
```

## Working with `nifti` objects

Again, we can use a logical operation.  Let's get the values of the `t1` greater than 400 (`head` only prints the first 6 values):

```{r}
head(t1[ t1 > 400 ])
```

## Working with `nifti` objects: reassignment 

Subsetting can work on the left hand side of assignment too:

```{r}
t1_copy = t1
t1_copy[ t1_copy > 400] = 400 # changed these values!
max(t1_copy) # should be 400
max(t1) 
```

Note, although `t1_copy` was copied from `t1`, they are not linked - if you change values in `t1_copy`, values in `t1` are unchanged.


## Writing Images out

We now can write out this modified `t1_copy` image:
```{r}
writenii(nim = t1_copy, 
         filename = "training01_mprage_under400.nii.gz")
file.exists("training01_mprage_under400.nii.gz")
```

## File helpers

Use `paste` if you want to put strings together with spaces:

Use `paste0` if you want no spaces by default:

`file.path(directory, filename)` will paste `directory` and `filename` with file separators (e.g. `/`)

```{r}
paste("img", ".nii.gz")
paste0("img", ".nii.gz")
file.path("output_directory", paste0("img", ".nii.gz"))
```

## Operations with `nifti` objects

- Comparison: `>`, `>=`, `<`, `<=`, `==` (equals), `!=` (not equal)
- Logical: `!` - not, `&` - and, `|` - or (a "pipe")
- Arithmetic: `+`, `-`, `*`, `/`, `^` - exponents
- Standard math functions: `log`, `abs`, `sqrt`

These work with an image and a number (`img + 2`) or two images of the same dimensions `img1 + img2`.


## Main Packages we will use

* `oro.nifti` - reading/writing NIfTI images
* `neurobase` - extends `oro.nifti` and provides helpful imaging functions
* `fslr` - wraps FSL commands to use in R
    - registration, image manipulation
* `ANTsR` - wrapper for Advanced normalization tools (ANTs) code 
    - registration, inhomogeneity correction, lots of tools
* `extrantsr` - allows `ANTsR` to work with objects from `oro.nifti` 

## Data Packages we will use
 
* `ms.lesion` - contains training/testing data of patients with multiple sclerosis (MS)
    - from the MS lesion challenge 2016 (http://iacl.ece.jhu.edu/index.php/MSChallenge)
* `kirby21.t1` - scan-rescan data for 3 subjects from @landman2011multi
    - https://www.nitrc.org/projects/multimodal


## Conclusions

- We have (briefly) covered some R data classes and types to get you started
- We will be using `nifti` objects
    - They are special 3-dimensional arrays
    - Contain numbers or logicals
- We have briefly covered subsetting and image manipulation
    - more on that later


## Lists

- Initialize an empty list and add two elements to it

```{r list}
l = list()
l[[1]] = v
l[[2]] = m
print(l)
```

- Subsetting:
```{r listSub}
print(l[[1]])
```
